<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Range bounding ¬∑ TaylorModels.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">TaylorModels.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href>Range bounding</a><ul class="internal"><li><a class="tocitem" href="#One-dimensional-bounding"><span>One-dimensional bounding</span></a></li><li><a class="tocitem" href="#Mincing"><span>Mincing</span></a></li><li><a class="tocitem" href="#Internal-representation"><span>Internal representation</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Range bounding</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Range bounding</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaIntervals/TaylorModels.jl/blob/master/docs/src/range_bounding.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Taylor-model-variables-and-range-bounding"><a class="docs-heading-anchor" href="#Taylor-model-variables-and-range-bounding">Taylor model variables and range bounding</a><a id="Taylor-model-variables-and-range-bounding-1"></a><a class="docs-heading-anchor-permalink" href="#Taylor-model-variables-and-range-bounding" title="Permalink"></a></h1><p>Taylor models can be applied to the problem of range bounding, that is to find an interval <span>$I \subseteq \mathbb{R}$</span> such that <span>$f(x) \in I$</span> on a given domain <span>$x \in D$</span> (including possible floating point errors, see examples below). There are several ways to construct a Taylor model. A convenient way is to define a &quot;Taylor model variable&quot;, which is then passed as argument to Julia functions. The following examples should help to clarify this method. To simplify the presentation we have only considered the univariate case, but this package can also handle multivariate Taylor models with the <code>TaylorModelN</code> type.</p><p>Here we construct a Taylor model variable specifying that:</p><ul><li>The truncation order is 3.</li><li>The expansion is around the origin (<code>interval(0)</code>).</li><li>The domain is the real interval centered around the origin <span>$[-0.5, 0.5]$</span>.</li></ul><pre><code class="language-julia">using TaylorModels

t = TaylorModel1(3, interval(0), -0.5..0.5)</code></pre><pre class="documenter-example-output"> [1, 1] t + [0, 0]</pre><p>Here the polynomial part is (the interval) <span>$1$</span>, and the remainder is zero. We can pass this Taylor model variable to any Julia function, for example:</p><pre><code class="language-julia">texp = exp(t)</code></pre><pre class="documenter-example-output"> [1, 1] + [1, 1] t + [0.5, 0.5] t¬≤ + [0.166666, 0.166667] t¬≥ + [-0, 0.00288794]</pre><p>This expression is a polynomial of order 3 (in agreement with the truncation order specified in the construction of <code>t</code>), whose coefficients are intervals that are guaranteed to contain the exact coefficient of the Taylor expansion of the function <span>$t \mapsto e^t$</span> in <span>$D : [-0.5, 0.5] \subset \mathbb{R}$</span>. Similarly, we can expand trigonometric functions such as <span>$t \mapsto \sin(t)$</span>:</p><pre><code class="language-julia">tsin = sin(t)</code></pre><pre class="documenter-example-output"> [1, 1] t + [-0.166667, -0.166666] t¬≥ + [-0.00124851, 0.00124851]</pre><p>Common arithmetic operators, such as addition (<code>+</code>) and multiplication (<code>*</code>) work with Taylor model variables out-of-the-box:</p><pre><code class="language-julia">s = texp + tsin</code></pre><pre class="documenter-example-output"> [1, 1] + [2, 2] t + [0.5, 0.5] t¬≤ + [-2.77556e-17, 2.77556e-17] t¬≥ + [-0.00124851, 0.00413645]</pre><pre><code class="language-julia">p = texp * tsin</code></pre><pre class="documenter-example-output"> [1, 1] t + [1, 1] t¬≤ + [0.333333, 0.333334] t¬≥ + [-0.0065406, 0.00610658]</pre><h2 id="One-dimensional-bounding"><a class="docs-heading-anchor" href="#One-dimensional-bounding">One-dimensional bounding</a><a id="One-dimensional-bounding-1"></a><a class="docs-heading-anchor-permalink" href="#One-dimensional-bounding" title="Permalink"></a></h2><p>To bound the range of a Taylor model in one variable, use the function <code>bound_taylor1</code>:</p><pre><code class="language-julia">using TaylorModels: bound_taylor1

[bound_taylor1(x) for x in [s, p]]</code></pre><pre class="documenter-example-output">2-element Vector{Interval{Float64}}:
  [0.124999, 2.12501]
 [-0.291667, 0.791667]</pre><p>This shows in particular that <span>$0.12499 \leq e^t + \sin(t) \leq 2.12501$</span> and that <span>$-0.291667 \leq e^t \sin(t) \leq 0.791667$</span> for all <span>$t \in D$</span>. Such bounds are in general not tight.</p><h2 id="Mincing"><a class="docs-heading-anchor" href="#Mincing">Mincing</a><a id="Mincing-1"></a><a class="docs-heading-anchor-permalink" href="#Mincing" title="Permalink"></a></h2><p>If desired, the common approach to improve the bounds is to evaluate the Taylor model on a smaller interval, e.g.</p><pre><code class="language-julia">D = domain(s) # domain -0.5 .. 0.5

E = evaluate(s, D) # original, no mincing</code></pre><pre class="documenter-example-output">[-0.00124851, 2.12914]</pre><pre><code class="language-julia">Dm = mince(D, 8) # split the domain into 8 smaller chunks

Em = evaluate.(s, Dm) # evaluate the Taylor model on each sub-domain

Rm = reduce(hull, Em) # take the convex hull, i.e. the smallest interval that contains them all</code></pre><pre class="documenter-example-output">[0.0690639, 2.12914]</pre><p>Here the lower bound has been improved by mincing (or splitting) the domain, and it may improve by repeating such operation recursively on smaller domains. In particular, the fact that the lower bound is greater than zero constitutes an algorithmic proof that <span>$s : t \mapsto e^t + \sin(t)$</span> is positive on <span>$D$</span>. Let&#39;s visualize the function <span>$s(t)$</span> and the bounds obtained so far.</p><pre><code class="language-">using Plots

Dt = range(-0.5, 0.5, length=100)

fig = plot(xlab=&quot;t&quot;, ylab=&quot;s(t)&quot;, legend=:topleft)
plot!(fig, Dt, t -&gt; exp(t) + sin(t), lab=&quot;&quot;, c=:black)

# range bounds
plot!(fig, Dt, t -&gt; sup(E), lab=&quot;N = 1&quot;, c=:blue, style=:dash)
plot!(fig, Dt, t -&gt; inf(E), c=:blue, lab=&quot;&quot;, style=:dash)

plot!(fig, Dt, t -&gt; sup(Rm), lab=&quot;N = 8&quot;, c=:red, style=:dash)
plot!(fig, Dt, t -&gt; inf(Rm), c=:red, lab=&quot;&quot;, style=:dash)

R16 = reduce(hull, evaluate.(s, mince(D, 16)))
plot!(fig, Dt, t -&gt; sup(R16), lab=&quot;N = 16&quot;, c=:orange, style=:dash)
plot!(fig, Dt, t -&gt; inf(R16), c=:orange, lab=&quot;&quot;, style=:dash)</code></pre><h2 id="Internal-representation"><a class="docs-heading-anchor" href="#Internal-representation">Internal representation</a><a id="Internal-representation-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-representation" title="Permalink"></a></h2><p>Consider again the Taylor model variable from the <a href="#Taylor-model-variables-and-range-bounding">Taylor model variables and range bounding</a> example.</p><pre><code class="language-julia">t</code></pre><pre class="documenter-example-output"> [1, 1] t + [0, 0]</pre><p>Such constructor is an alias for</p><pre><code class="language-julia">    TaylorModel1(x0 + Taylor1(eltype(x0), ord), zero(dom), interval(x0), dom)</code></pre><p>Taylor models in one variable are internally represented using four fields: a Taylor series (<code>pol</code>) in one variable that holds the polynomial approximation of order <code>ord</code>; the interval remainder (<code>rem</code>); the expansion point (<code>x0</code>), and the interval domain of interest (<code>dom</code>). Getter functions are defined for each of these fields:</p><pre><code class="language-julia">get_order(t)</code></pre><pre class="documenter-example-output">3</pre><pre><code class="language-julia">remainder(t)</code></pre><pre class="documenter-example-output">[0, 0]</pre><pre><code class="language-julia">polynomial(t)</code></pre><pre class="documenter-example-output"> [1, 1] t + ùí™(t‚Å¥)</pre><pre><code class="language-julia">domain(t)</code></pre><pre class="documenter-example-output">[-0.5, 0.5]</pre><pre><code class="language-julia">expansion_point(t)</code></pre><pre class="documenter-example-output">[0, 0]</pre><p>Finally, note that the Taylor model type has two parameters, <code>T</code> and <code>S</code>. The first parameter, <code>T</code>, refers to the numeric type of the coefficients of the polynomial, in this case an interval with double precision floating point values (<code>Interval{Float64}</code>). The second parameter, <code>S</code>, refers to the numeric type of the interval that holds the remainder, expansion point and domain of interest (in this case <code>Float64</code>).</p><pre><code class="language-julia">typeof(t)</code></pre><pre class="documenter-example-output">TaylorModel1{Interval{Float64}, Float64}</pre><p>If we had defined the expansion point using <code>0.0</code> instead of <code>interval(0)</code>, the coefficients of (the polynomial part of) this Taylor model variable would be floats instead of intervals.</p><pre><code class="language-julia">z = TaylorModel1(3, 0.0, -0.5..0.5)</code></pre><pre class="documenter-example-output"> 1.0 t + [0, 0]</pre><pre><code class="language-julia">typeof(z)</code></pre><pre class="documenter-example-output">TaylorModel1{Float64, Float64}</pre><pre><code class="language-julia">polynomial(z)</code></pre><pre class="documenter-example-output"> 1.0 t + ùí™(t‚Å¥)</pre><p>Using a polynomial with interval coefficients guarantees that all arithmetic operations involving <code>t</code> are conservative, or rigorous, with respect to floating point arithmetic.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">¬´ Home</a><a class="docs-footer-nextpage" href="../api/">API ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 14 May 2021 01:00">Friday 14 May 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
