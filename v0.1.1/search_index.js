var documenterSearchIndex = {"docs":
[{"location":"#TaylorModels.jl-1","page":"Home","title":"TaylorModels.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This package combines the IntervalArithmetic.jl and TaylorSeries.jl packages to provide Taylor models, i.e. Taylor polynomials with guaranteed error bounds to approximate functions.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"An introduction is available in this video from JuliaCon 2018.","category":"page"},{"location":"#Introduction-to-Taylor-Models-1","page":"Home","title":"Introduction to Taylor Models","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Taylor models provide a way to rigorously manipulate and evaluate functions using floating-point arithmetic. They have been widely used for validated computing: in global optimization and range bounding, for validated solutions of ODEs, rigorous quadrature, etc.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"A Taylor model (TM) of order n for a function f which is supposed to be n + 1 times continuously differentiable over an interval ab, is a rigorous polynomial approximation of f. Specifically, it is a couple (P Delta) formed by a polynomial P of degree n, and an interval part Delta, such that f(x)  P(x) in Delta, forall x  ab. Roughly speaking, as their name suggests, the polynomial can be seen as a Taylor expansion of the function at a given point. The interval Delta (also called interval remainder) provides the validation of the approximation, meaning that it provides an enclosure of all the approximation errors encountered (truncation, roundings).","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Here we generate TMs of order 6 and 7 over I = -0510. We can view a TM as a a tube around the actual function.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using TaylorModels\n\nf(x) = x*(x-1.1)*(x+2)*(x+2.2)*(x+2.5)*(x+3)*sin(1.7*x+0.5)\na =  -0.5 .. 1.0 # Domain \nx0 = mid(a)     # Expansion point\ntm6 = TaylorModel1(6, interval(x0), a) # Independent variable for Taylor models, order 6\ntm7 = TaylorModel1(7, interval(x0), a)  # Independent variable for Taylor models, order 7\n# Taylor models corresponding to f(x) of order 6 and 7\nftm6 = f(tm6)\nftm7 = f(tm7)\n\n# Now the plot\nusing Plots; gr()\nplot(range(inf(a), stop=sup(a), length=1000), x->f(x), label=\"f(x)\", lw=2, xaxis=\"x\", yaxis=\"f(x)\")\nplot!(ftm6, label=\"6th order\")\nplot!(ftm7, label=\"7th order\")","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: intro_plot)","category":"page"},{"location":"#Authors-1","page":"Home","title":"Authors","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Luis Benet, Instituto de Ciencias Físicas, Universidad Nacional Autónoma de México (UNAM)\nDavid P. Sanders, Departamento de Física, Facultad de Ciencias, Universidad Nacional Autónoma de México (UNAM)","category":"page"},{"location":"#Bibliography-1","page":"Home","title":"Bibliography","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Rigorous Polynomial Approximations and Applications, Mioara Maria Joldes, Ecole normale supérieure de lyon - ENS LYON (2011)","category":"page"},{"location":"#Acknowledgements-1","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Financial support is acknowledged from DGAPA-UNAM PAPIIT grants IN-117117, IG-100616 and IG-100819. DPS acknowledges support through a Cátedra Marcos Moshinsky (2018).","category":"page"},{"location":"api/#TaylorModels.jl-1","page":"API","title":"TaylorModels.jl","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"","category":"page"},{"location":"api/#","page":"API","title":"API","text":"Modules = [TaylorModels]","category":"page"},{"location":"api/#TaylorModels.RTaylorModel1","page":"API","title":"TaylorModels.RTaylorModel1","text":"RTaylorModel1{T,S}\n\nTaylor model in 1 variable, providing a rigurous polynomial approximation (around x_0) and a relative remainder \\delta for a function f(x) in one variable, valid in the interval dom. Corresponds to definition 2.3.2 of Mioara Joldes' thesis.\n\nFields:\n\npol: polynomial approximation, represented as TaylorSeries.Taylor1\nrem: the interval bound\nx0 : expansion point\ndom: domain, interval over which the Taylor model is defined / valid\n\nThe approximation f(x) = \\sum_i p_i (x - x_0)^i + \\delta (x - x_0)^{n+1} is satisfied for all x\\in dom; n is the order (degree) of the polynomial p(x).\n\n\n\n","category":"type"},{"location":"api/#TaylorModels.TaylorModel1","page":"API","title":"TaylorModels.TaylorModel1","text":"TaylorModel1{T,S}\n\nTaylor model in 1 variable, providing a rigurous polynomial approximation (around x_0) and an absolute remainder \\Delta for a function f(x) in one variable, valid in the interval dom. Corresponds to definition 2.1.3 of Mioara Joldes' thesis.\n\nFields:\n\npol: polynomial approximation, represented as TaylorSeries.Taylor1\nrem: the interval bound\nx0 : expansion point\ndom: domain, interval over which the Taylor model is defined / valid\n\nThe approximation f(x) = \\sum_{i=0}^n p_i (x - x_0)^i + \\Delta is satisfied for all x\\in dom (0\\in\\Delta); n is the order (degree) of the polynomial p(x).\n\n\n\n","category":"type"},{"location":"api/#TaylorModels.TaylorModelN","page":"API","title":"TaylorModels.TaylorModelN","text":"TaylorModelN{N,T,S}\n\nTaylor Models with absolute remainder for N independent variables.\n\n\n\n\n\n","category":"type"},{"location":"api/#TaylorModels.bound_absrem-Tuple{Function,Taylor1,Taylor1,Any,Interval}","page":"API","title":"TaylorModels.bound_absrem","text":"bound_absrem(f::Function, polf::Taylor1, polfI::Taylor1, x0::Interval, I::Interval)\n\nBound the absolute remainder of the polynomial approximation of f given by the Taylor polynomial polf around x0 on the interval I. It requires the interval extension polfI of the polynomial that approximates f for the whole interval I, in order to compute the Lagrange remainder.\n\nIf polfI[end] has a definite sign, then it is monotonic in the intervals [I.lo, x0] and [x0.hi, I.hi], which is exploited; otherwise, it is used to compute the Lagrange remainder.\n\n\n\n\n\n","category":"method"},{"location":"api/#TaylorModels.bound_relrem-Tuple{Function,Taylor1,Taylor1,Interval,Interval}","page":"API","title":"TaylorModels.bound_relrem","text":"bound_relrem(f::Function, polf::Taylor1, polfI::Taylor1, x0::Interval, I::Interval)\n\nBound the relative remainder of the polynomial approximation of f given by the Taylor polynomial polf around x0 on the interval I. It requires an the interval extension polfI of a polynomial that approximates f for the whole interval I, in order to compute the Lagrange remainder.\n\nIf polfI[end] has a definite sign, then it is monotonic in the interval I, which is exploited; otherwise, the last coefficients bounds the relative remainder.\n\n\n\n\n\n","category":"method"},{"location":"api/#TaylorModels.fp_rpa-Union{Tuple{TaylorModel1{Interval{T},T}}, Tuple{T}} where T","page":"API","title":"TaylorModels.fp_rpa","text":"fp_rpa(tm::TaylorModel1{Interval{T},T})\nfp_rpa(tm::RTaylorModel1{Interval{T},T})\n\nConvert a tm TaylorModel1 to a TaylorModel1 whose polynomial coefficients are Float64. The accumulated error is added to the remainder. The mid point of the expansion interval is preferentially rounded down if it is not an exactly representable value.\n\n\n\n\n\n","category":"method"},{"location":"api/#TaylorModels.rpa-Tuple{Function,RTaylorModel1}","page":"API","title":"TaylorModels.rpa","text":"rpa(g::Function, tmf::RTaylorModel1)\n\nRigurous polynomial approximation (RPA) for the function g using the Taylor Model with absolute remainder tmf. The bound is computed exploiting monotonicity if possible, otherwise, it uses Lagrange bound.\n\n\n\n\n\n","category":"method"},{"location":"api/#TaylorModels.rpa-Tuple{Function,TaylorModel1}","page":"API","title":"TaylorModels.rpa","text":"rpa(g::Function, tmf::TaylorModel1)    rpa(g::Function, tmf::TaylorModelN)\n\nRigurous polynomial approximation (RPA) for the function g using the Taylor Model with absolute remainder tmf. The bound is computed exploiting monotonicity if possible, otherwise, it uses Lagrange bound.\n\n\n\n\n\n","category":"method"},{"location":"api/#TaylorSeries.integrate-Union{Tuple{S}, Tuple{T}, Tuple{TaylorModel1{T,S},T}} where S where T","page":"API","title":"TaylorSeries.integrate","text":"integrate(a, c0)\n\nIntegrates the one-variable Taylor Model (TaylorModel1 or RTaylorModel1) with respect to the independent variable; c0 is the interval representing the integration constant; if omitted it is considered as the zero interval.\n\n\n\n\n\n","category":"method"},{"location":"api/#TaylorModels._rpaar-Union{Tuple{T}, Tuple{Function,Interval{T},Interval{T},Integer}} where T","page":"API","title":"TaylorModels._rpaar","text":"_rpaar(f::Function, x0::Interval, I::Interval, _order::Integer)\n\nRigurous polynomial approximation (RPA) with absolute remainder for the function f on the interval I,  using a Taylor expansion around the interval x0 of order _order. The bound is computed by bound_absrem(@ref) exploiting monotonicity if possible, otherwise, it uses Lagrange bound.\n\n\n\n\n\n","category":"method"},{"location":"api/#TaylorModels._rparr-Union{Tuple{T}, Tuple{Function,Any,Interval{T},Integer}} where T","page":"API","title":"TaylorModels._rparr","text":"_rparr(f::Function, x0::Interval, I::Interval, _order::Integer)\n\nRigurous polynomial approximation (RPA) with relative remainder for the function f on the interval I,  using a Taylor expansion around the interval x0 of order _order. The bound is computed by bound_relrem(@ref) exploiting monotonicity if possible, otherwise, it uses the Lagrange coefficient.\n\n\n\n\n\n","category":"method"},{"location":"api/#TaylorModels.absorb_remainder-Union{Tuple{TaylorModelN{N,T,T}}, Tuple{T}, Tuple{N}} where T where N","page":"API","title":"TaylorModels.absorb_remainder","text":"absorb_remainder(a::TaylorModelN{N,T,T}) where {N,T}\n\nReturns a TaylorModelN, equivalent to a, such that the remainder is mostly absorbed in the coefficients. The linear shift assumes that a is normalized to the IntervalBox(-1..1, Val(N)).\n\nRef: Xin Chen, Erika Abraham, and Sriram Sankaranarayanan, \"Taylor Model Flowpipe Construction for Non-linear Hybrid Systems\", in Real Time Systems Symposium (RTSS), pp. 183-192 (2012), IEEE Press.\n\n\n\n\n\n","category":"method"},{"location":"api/#TaylorModels.bound_integration-Union{Tuple{S}, Tuple{T}, Tuple{TaylorModel1{T,S},Any}} where S where T","page":"API","title":"TaylorModels.bound_integration","text":"bound_integration(xTM1::TaylorModel1{Interval{S},S}, δt::Interval{S})\nbound_integration(xTM1::Vector{TaylorModel1{Interval{S},S}}, δt::Interval{S})\n\nRemainder bound for the integration of a series, given by δ * remainder(a) +  apolorder * δ^(order+1)  (order+1). This is tighter that the one used by Berz+Makino, which corresponds to Δ = aux * remainder(a) +  apolorder * aux^(order+1).\n\n\n\n\n\n","category":"method"},{"location":"api/#TaylorModels.bound_taylor1-Tuple{Taylor1,Interval}","page":"API","title":"TaylorModels.bound_taylor1","text":"bound_taylor1(fT::Taylor1, I::Interval)\n\nCompute a tight polynomial bound for the Taylor polynomial fT in the interval I.\n\nNote: Algorithm 2.1.1 corresponds to evaluate(fT, I) or simply fT(I). This function uses the roots of the derivative offt` to obtain a tighter bound.\n\n\n\n\n\n","category":"method"},{"location":"api/#TaylorModels.bound_taylor1-Union{Tuple{T}, Tuple{Taylor1{T},Taylor1{T},Interval{T}}} where T","page":"API","title":"TaylorModels.bound_taylor1","text":"bound_taylor1(fT::Taylor1, fTd::Taylor1, I::Interval)\n\nCompute a tight polynomial bound for the Taylor polynomial fT in the interval I, considering whether its derivative ftd has a definite sign.\n\n\n\n\n\n","category":"method"},{"location":"api/#TaylorModels.check_existence-Union{Tuple{T}, Tuple{Any,T,T,Interval,Interval}, Tuple{Any,T,T,Interval,Interval,Integer}} where T<:Union{RTaylorModel1, TaylorModel1}","page":"API","title":"TaylorModels.check_existence","text":"check_existence(f, tm::T, xm::T, x0::Interval, x_test::Interval)\n\nChecks that the range of one iterate of the Picard-Lindelöf operator is contained in the a-priori interval x_test (of the dependent variable) that bounds the solution of the ODE defined by f. This function returns an interval of the independent variable where the a-priori solution is warranted to exist; see shrink_for_existance. Here, tm and xm are Taylor Models (TaylorModel1 or RTaylorModel1) defined for the independent and dependent variables, and x0 is the initial condition.\n\n\n\n\n\n","category":"method"},{"location":"api/#TaylorModels.iscontractive-Union{Tuple{T}, Tuple{N}, Tuple{IntervalBox{N,T},IntervalBox{N,T}}} where T where N","page":"API","title":"TaylorModels.iscontractive","text":"iscontractive(Δ, Δx)\n\nChecks if Δ .⊂ Δx is satisfied. If `Δ ⊆ Δx is satisfied, it returns true if all cases where == holds corresponds to the zero Interval.\n\n\n\n\n\n","category":"method"},{"location":"api/#TaylorModels.picard_lindelöf-Union{Tuple{T}, Tuple{Any,T,T,Interval}} where T<:Union{RTaylorModel1, TaylorModel1}","page":"API","title":"TaylorModels.picard_lindelöf","text":"picard_lindelöf(f, tm::T, xm::T, x0::Interval)\n𝒫(f, tm::T, xm::T, x0::Interval)\n\nReturns the application of the Picard-Lindelöf operator associated to the ODE dotx = f(tx), with initial condition x0. Here, tm and xm are (one-variable) Taylor Models (TaylorModel1 or RTaylorModel1).\n\n𝒫 is an abbreviation of this operator, which is obtained as \\mscrP<TAB>.)\n\n\n\n\n\n","category":"method"},{"location":"api/#TaylorModels.picard_remainder!-Union{Tuple{T}, Tuple{N}, Tuple{Function,Taylor1{T},Array{Taylor1{TaylorN{T}},1},Array{Taylor1{TaylorN{T}},1},Array{Taylor1{TaylorN{Interval{T}}},1},Array{Taylor1{TaylorN{Interval{T}}},1},IntervalBox{N,T},Interval{T},IntervalBox{N,T},IntervalBox{N,T}}} where T where N","page":"API","title":"TaylorModels.picard_remainder!","text":"picard_remainder!(f!, t, x, dx, xxI, dxxI, δI, δt, Δx, Δ0)\n\nReturn the remainder of Picard operator\n\n\n\n\n\n","category":"method"},{"location":"api/#TaylorModels.reducetoorder-Tuple{RTaylorModel1,Integer}","page":"API","title":"TaylorModels.reducetoorder","text":"reducetoorder(a::RTaylorModel1, m::Integer)\n\nFrom a::RTaylorModel1, it returns a RTaylorModel1 of order m.\n\n\n\n\n\n","category":"method"},{"location":"api/#TaylorModels.remainder_taylorstep!-Union{Tuple{T}, Tuple{N}, Tuple{Function,Taylor1{T},Array{Taylor1{TaylorN{T}},1},Array{Taylor1{TaylorN{T}},1},Array{Taylor1{Interval{T}},1},Array{Taylor1{Interval{T}},1},IntervalBox{N,T},Interval{T}}} where T where N","page":"API","title":"TaylorModels.remainder_taylorstep!","text":"remainder_taylorstep!(f!, t, x, dx, xI, dxI, δI, δt)\n\nReturns a remainder for the integration step for the dependent variables (x) checking that the solution satisfies the criteria for existence and uniqueness.\n\n\n\n\n\n","category":"method"},{"location":"api/#TaylorModels.shrink_for_existance-Union{Tuple{T}, Tuple{T,Any,Any}, Tuple{T,Any,Any,Integer}} where T<:Union{RTaylorModel1, TaylorModel1}","page":"API","title":"TaylorModels.shrink_for_existance","text":"shrink_for_existance(xm::T, t_interval, x_test, max_steps::Integer=20)\n\nShrinks the a-priori independent-variable interval t_interval so the range of xm, the Taylor Model (TaylorModel1 or RTaylorModel1) associated with the dependent variable, is contained in the a-priori interval x_test. The method used is some sort of bisection. If no independent-variable interval is found within max_steps, an empty interval is returned.\n\n\n\n\n\n","category":"method"},{"location":"api/#TaylorModels.tight_remainder-Union{Tuple{T}, Tuple{Any,T,T,Interval}, Tuple{Any,T,T,Interval,Integer}} where T<:Union{RTaylorModel1, TaylorModel1}","page":"API","title":"TaylorModels.tight_remainder","text":"tight_remainder(f, tm::T, xm::T, x0::Interval, max_steps::Integer=20)\n\nReturns a Taylor Model for the dependent variable, with a tighter remainder, which is obtained after successive iteration of the Picard-Lindelöf. If the remainder is not tighter (and identity with the former iterate is not obtained) a Taylor Model with an empty interval is returned.\n\n\n\n\n\n","category":"method"},{"location":"api/#TaylorModels.validated_step!-Union{Tuple{T}, Tuple{N}, Tuple{Any,Taylor1{T},Array{Taylor1{TaylorN{T}},1},Array{Taylor1{TaylorN{T}},1},Array{Taylor1{TaylorN{T}},1},Taylor1{T},Array{Taylor1{Interval{T}},1},Array{Taylor1{Interval{T}},1},Array{Taylor1{Interval{T}},1},T,T,Array{TaylorN{T},1},Array{Interval{T},1},Array{TaylorModelN{N,T,T},1},Array{IntervalBox{N,T},1},Array{Interval{T},1},IntervalBox{N,T},IntervalBox{N,T},IntervalBox{N,T},Int64,Int64,T,Bool}, Tuple{Any,Taylor1{T},Array{Taylor1{TaylorN{T}},1},Array{Taylor1{TaylorN{T}},1},Array{Taylor1{TaylorN{T}},1},Taylor1{T},Array{Taylor1{Interval{T}},1},Array{Taylor1{Interval{T}},1},Array{Taylor1{Interval{T}},1},T,T,Array{TaylorN{T},1},Array{Interval{T},1},Array{TaylorModelN{N,T,T},1},Array{IntervalBox{N,T},1},Array{Interval{T},1},IntervalBox{N,T},IntervalBox{N,T},IntervalBox{N,T},Int64,Int64,T,Bool,Function}} where T where N","page":"API","title":"TaylorModels.validated_step!","text":"validated-step!\n\n\n\n\n\n","category":"method"}]
}
