<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · TaylorModels.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>TaylorModels.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>API</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>API</a></li></ul><a class="edit-page" href="https://github.com/JuliaIntervals/TaylorModels.jl/blob/master/docs/src/api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>API</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="TaylorModels.jl-1" href="#TaylorModels.jl-1">TaylorModels.jl</a></h1><ul><li><a href="#TaylorModels.RTaylorModel1"><code>TaylorModels.RTaylorModel1</code></a></li><li><a href="#TaylorModels.TaylorModel1"><code>TaylorModels.TaylorModel1</code></a></li><li><a href="#TaylorModels.TaylorModelN"><code>TaylorModels.TaylorModelN</code></a></li><li><a href="#TaylorModels._rpaar-Union{Tuple{T}, Tuple{Function,Interval{T},Interval{T},Integer}} where T"><code>TaylorModels._rpaar</code></a></li><li><a href="#TaylorModels._rparr-Union{Tuple{T}, Tuple{Function,Any,Interval{T},Integer}} where T"><code>TaylorModels._rparr</code></a></li><li><a href="#TaylorModels.absorb_remainder-Union{Tuple{TaylorModelN{N,T,T}}, Tuple{T}, Tuple{N}} where T where N"><code>TaylorModels.absorb_remainder</code></a></li><li><a href="#TaylorModels.bound_absrem-Tuple{Function,Taylor1,Taylor1,Any,Interval}"><code>TaylorModels.bound_absrem</code></a></li><li><a href="#TaylorModels.bound_integration-Union{Tuple{S}, Tuple{T}, Tuple{TaylorModel1{T,S},Any}} where S where T"><code>TaylorModels.bound_integration</code></a></li><li><a href="#TaylorModels.bound_relrem-Tuple{Function,Taylor1,Taylor1,Interval,Interval}"><code>TaylorModels.bound_relrem</code></a></li><li><a href="#TaylorModels.bound_taylor1-Union{Tuple{T}, Tuple{Taylor1{T},Taylor1{T},Interval{T}}} where T"><code>TaylorModels.bound_taylor1</code></a></li><li><a href="#TaylorModels.bound_taylor1-Tuple{Taylor1,Interval}"><code>TaylorModels.bound_taylor1</code></a></li><li><a href="#TaylorModels.check_existence-Union{Tuple{T}, Tuple{Any,T,T,Interval,Interval}, Tuple{Any,T,T,Interval,Interval,Integer}} where T&lt;:Union{RTaylorModel1, TaylorModel1}"><code>TaylorModels.check_existence</code></a></li><li><a href="#TaylorModels.fp_rpa-Union{Tuple{TaylorModel1{Interval{T},T}}, Tuple{T}} where T"><code>TaylorModels.fp_rpa</code></a></li><li><a href="#TaylorModels.iscontractive-Union{Tuple{T}, Tuple{N}, Tuple{IntervalBox{N,T},IntervalBox{N,T}}} where T where N"><code>TaylorModels.iscontractive</code></a></li><li><a href="#TaylorModels.picard_lindelöf-Union{Tuple{T}, Tuple{Any,T,T,Interval}} where T&lt;:Union{RTaylorModel1, TaylorModel1}"><code>TaylorModels.picard_lindelöf</code></a></li><li><a href="#TaylorModels.picard_remainder!-Union{Tuple{T}, Tuple{N}, Tuple{Function,Taylor1{T},Array{Taylor1{TaylorN{T}},1},Array{Taylor1{TaylorN{T}},1},Array{Taylor1{TaylorN{Interval{T}}},1},Array{Taylor1{TaylorN{Interval{T}}},1},IntervalBox{N,T},Interval{T},IntervalBox{N,T},IntervalBox{N,T},Any}} where T where N"><code>TaylorModels.picard_remainder!</code></a></li><li><a href="#TaylorModels.reducetoorder-Tuple{RTaylorModel1,Integer}"><code>TaylorModels.reducetoorder</code></a></li><li><a href="#TaylorModels.remainder_taylorstep!-Union{Tuple{T}, Tuple{N}, Tuple{Function,Taylor1{T},Array{Taylor1{TaylorN{T}},1},Array{Taylor1{TaylorN{T}},1},Array{Taylor1{Interval{T}},1},Array{Taylor1{Interval{T}},1},IntervalBox{N,T},Interval{T},Any}} where T where N"><code>TaylorModels.remainder_taylorstep!</code></a></li><li><a href="#TaylorModels.rpa-Tuple{Function,RTaylorModel1}"><code>TaylorModels.rpa</code></a></li><li><a href="#TaylorModels.rpa-Tuple{Function,TaylorModel1}"><code>TaylorModels.rpa</code></a></li><li><a href="#TaylorModels.shrink_for_existance-Union{Tuple{T}, Tuple{T,Any,Any}, Tuple{T,Any,Any,Integer}} where T&lt;:Union{RTaylorModel1, TaylorModel1}"><code>TaylorModels.shrink_for_existance</code></a></li><li><a href="#TaylorModels.shrink_wrapping!-Union{Tuple{Array{TaylorModelN{N,T,T},1}}, Tuple{T}, Tuple{N}} where T where N"><code>TaylorModels.shrink_wrapping!</code></a></li><li><a href="#TaylorModels.tight_remainder-Union{Tuple{T}, Tuple{Any,T,T,Interval}, Tuple{Any,T,T,Interval,Integer}} where T&lt;:Union{RTaylorModel1, TaylorModel1}"><code>TaylorModels.tight_remainder</code></a></li><li><a href="#TaylorModels.validated_step!-Union{Tuple{T}, Tuple{N}, Tuple{Any,Taylor1{T},Array{Taylor1{TaylorN{T}},1},Array{Taylor1{TaylorN{T}},1},Array{Taylor1{TaylorN{T}},1},Taylor1{T},Array{Taylor1{Interval{T}},1},Array{Taylor1{Interval{T}},1},Array{Taylor1{Interval{T}},1},T,T,Array{TaylorModelN{N,T,T},1},Array{IntervalBox{N,T},1},Array{Interval{T},1},IntervalBox{N,T},IntervalBox{N,T},IntervalBox{N,T},Int64,Int64,T,Any,Bool}, Tuple{Any,Taylor1{T},Array{Taylor1{TaylorN{T}},1},Array{Taylor1{TaylorN{T}},1},Array{Taylor1{TaylorN{T}},1},Taylor1{T},Array{Taylor1{Interval{T}},1},Array{Taylor1{Interval{T}},1},Array{Taylor1{Interval{T}},1},T,T,Array{TaylorModelN{N,T,T},1},Array{IntervalBox{N,T},1},Array{Interval{T},1},IntervalBox{N,T},IntervalBox{N,T},IntervalBox{N,T},Int64,Int64,T,Any,Bool,Function}} where T where N"><code>TaylorModels.validated_step!</code></a></li><li><a href="#TaylorSeries.integrate-Union{Tuple{S}, Tuple{T}, Tuple{TaylorModel1{T,S},T}} where S where T"><code>TaylorSeries.integrate</code></a></li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorModels.RTaylorModel1" href="#TaylorModels.RTaylorModel1"><code>TaylorModels.RTaylorModel1</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">RTaylorModel1{T,S}</code></pre><p>Taylor model in 1 variable, providing a rigurous polynomial approximation (around <code>x_0</code>) and a relative remainder <code>\delta</code> for a function <code>f(x)</code> in one variable, valid in the interval <code>dom</code>. Corresponds to definition 2.3.2 of Mioara Joldes&#39; thesis.</p><p>Fields:</p><ul><li><code>pol</code>: polynomial approximation, represented as <code>TaylorSeries.Taylor1</code></li><li><code>rem</code>: the interval bound</li><li><code>x0</code> : expansion point</li><li><code>dom</code>: domain, interval over which the Taylor model is defined / valid</li></ul><p>The approximation <code>f(x) = \sum_i p_i (x - x_0)^i + \delta (x - x_0)^{n+1}</code> is satisfied for all <code>x\in dom</code>; <code>n</code> is the order (degree) of the polynomial <code>p(x)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaIntervals/TaylorModels.jl/blob/f844624021de8479f3327d8ba178c76425262f8f/src/constructors.jl#L80">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorModels.TaylorModel1" href="#TaylorModels.TaylorModel1"><code>TaylorModels.TaylorModel1</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">TaylorModel1{T,S}</code></pre><p>Taylor model in 1 variable, providing a rigurous polynomial approximation (around <code>x_0</code>) and an absolute remainder <code>\Delta</code> for a function <code>f(x)</code> in one variable, valid in the interval <code>dom</code>. Corresponds to definition 2.1.3 of Mioara Joldes&#39; thesis.</p><p>Fields:</p><ul><li><code>pol</code>: polynomial approximation, represented as <code>TaylorSeries.Taylor1</code></li><li><code>rem</code>: the interval bound</li><li><code>x0</code> : expansion point</li><li><code>dom</code>: domain, interval over which the Taylor model is defined / valid</li></ul><p>The approximation <code>f(x) = \sum_{i=0}^n p_i (x - x_0)^i + \Delta</code> is satisfied for all <code>x\in dom</code> (<code>0\in\Delta</code>); <code>n</code> is the order (degree) of the polynomial <code>p(x)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaIntervals/TaylorModels.jl/blob/f844624021de8479f3327d8ba178c76425262f8f/src/constructors.jl#L60">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorModels.TaylorModelN" href="#TaylorModels.TaylorModelN"><code>TaylorModels.TaylorModelN</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">TaylorModelN{N,T,S}</code></pre><p>Taylor Models with absolute remainder for <code>N</code> independent variables.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIntervals/TaylorModels.jl/blob/f844624021de8479f3327d8ba178c76425262f8f/src/constructors.jl#L101-L106">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorModels.bound_absrem-Tuple{Function,Taylor1,Taylor1,Any,Interval}" href="#TaylorModels.bound_absrem-Tuple{Function,Taylor1,Taylor1,Any,Interval}"><code>TaylorModels.bound_absrem</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>bound_absrem(f::Function, polf::Taylor1, polfI::Taylor1, x0::Interval, I::Interval)</p><p>Bound the absolute remainder of the polynomial approximation of <code>f</code> given by the Taylor polynomial <code>polf</code> around <code>x0</code> on the interval <code>I</code>. It requires the interval extension <code>polfI</code> of the polynomial that approximates <code>f</code> for the whole interval <code>I</code>, in order to compute the Lagrange remainder.</p><p>If <code>polfI[end]</code> has a definite sign, then it is monotonic in the intervals [I.lo, x0] and [x0.hi, I.hi], which is exploited; otherwise, it is used to compute the Lagrange remainder.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIntervals/TaylorModels.jl/blob/f844624021de8479f3327d8ba178c76425262f8f/src/bounds.jl#L3-L15">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorModels.bound_relrem-Tuple{Function,Taylor1,Taylor1,Interval,Interval}" href="#TaylorModels.bound_relrem-Tuple{Function,Taylor1,Taylor1,Interval,Interval}"><code>TaylorModels.bound_relrem</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>bound_relrem(f::Function, polf::Taylor1, polfI::Taylor1, x0::Interval, I::Interval)</p><p>Bound the relative remainder of the polynomial approximation of <code>f</code> given by the Taylor polynomial <code>polf</code> around <code>x0</code> on the interval <code>I</code>. It requires an the interval extension <code>polfI</code> of a polynomial that approximates <code>f</code> for the whole interval <code>I</code>, in order to compute the Lagrange remainder.</p><p>If <code>polfI[end]</code> has a definite sign, then it is monotonic in the interval <code>I</code>, which is exploited; otherwise, the last coefficients bounds the relative remainder.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIntervals/TaylorModels.jl/blob/f844624021de8479f3327d8ba178c76425262f8f/src/bounds.jl#L39-L51">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorModels.fp_rpa-Union{Tuple{TaylorModel1{Interval{T},T}}, Tuple{T}} where T" href="#TaylorModels.fp_rpa-Union{Tuple{TaylorModel1{Interval{T},T}}, Tuple{T}} where T"><code>TaylorModels.fp_rpa</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">fp_rpa(tm::TaylorModel1{Interval{T},T})
fp_rpa(tm::RTaylorModel1{Interval{T},T})</code></pre><p>Convert a <code>tm</code> TaylorModel1 to a TaylorModel1 whose polynomial coefficients are <code>Float64</code>. The accumulated error is added to the remainder. The mid point of the expansion interval is preferentially rounded down if it is not an exactly representable value.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIntervals/TaylorModels.jl/blob/f844624021de8479f3327d8ba178c76425262f8f/src/rpa_functions.jl#L183-L192">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorModels.rpa-Tuple{Function,RTaylorModel1}" href="#TaylorModels.rpa-Tuple{Function,RTaylorModel1}"><code>TaylorModels.rpa</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>rpa(g::Function, tmf::RTaylorModel1)</p><p>Rigurous polynomial approximation (RPA) for the function <code>g</code> using the Taylor Model with absolute remainder <code>tmf</code>. The bound is computed exploiting monotonicity if possible, otherwise, it uses Lagrange bound.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIntervals/TaylorModels.jl/blob/f844624021de8479f3327d8ba178c76425262f8f/src/rpa_functions.jl#L135-L142">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorModels.rpa-Tuple{Function,TaylorModel1}" href="#TaylorModels.rpa-Tuple{Function,TaylorModel1}"><code>TaylorModels.rpa</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>rpa(g::Function, tmf::TaylorModel1)    rpa(g::Function, tmf::TaylorModelN)</p><p>Rigurous polynomial approximation (RPA) for the function <code>g</code> using the Taylor Model with absolute remainder <code>tmf</code>. The bound is computed exploiting monotonicity if possible, otherwise, it uses Lagrange bound.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIntervals/TaylorModels.jl/blob/f844624021de8479f3327d8ba178c76425262f8f/src/rpa_functions.jl#L51-L59">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.integrate-Union{Tuple{S}, Tuple{T}, Tuple{TaylorModel1{T,S},T}} where S where T" href="#TaylorSeries.integrate-Union{Tuple{S}, Tuple{T}, Tuple{TaylorModel1{T,S},T}} where S where T"><code>TaylorSeries.integrate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">integrate(a, c0)</code></pre><p>Integrates the one-variable Taylor Model (<code>TaylorModel1</code> or <code>RTaylorModel1</code>) with respect to the independent variable; <code>c0</code> is the interval representing the integration constant; if omitted it is considered as the zero interval.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIntervals/TaylorModels.jl/blob/f844624021de8479f3327d8ba178c76425262f8f/src/integration.jl#L3-L10">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorModels._rpaar-Union{Tuple{T}, Tuple{Function,Interval{T},Interval{T},Integer}} where T" href="#TaylorModels._rpaar-Union{Tuple{T}, Tuple{Function,Interval{T},Interval{T},Integer}} where T"><code>TaylorModels._rpaar</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>_rpaar(f::Function, x0::Interval, I::Interval, _order::Integer)</p><p>Rigurous polynomial approximation (RPA) with absolute remainder for the function <code>f</code> on the interval <code>I</code>,  using a Taylor expansion around the <em>interval</em> <code>x0</code> of order <code>_order</code>. The bound is computed by <code>bound_absrem</code>(@ref) exploiting monotonicity if possible, otherwise, it uses Lagrange bound.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIntervals/TaylorModels.jl/blob/f844624021de8479f3327d8ba178c76425262f8f/src/rpa_functions.jl#L8-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorModels._rparr-Union{Tuple{T}, Tuple{Function,Any,Interval{T},Integer}} where T" href="#TaylorModels._rparr-Union{Tuple{T}, Tuple{Function,Any,Interval{T},Integer}} where T"><code>TaylorModels._rparr</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>_rparr(f::Function, x0::Interval, I::Interval, _order::Integer)</p><p>Rigurous polynomial approximation (RPA) with relative remainder for the function <code>f</code> on the interval <code>I</code>,  using a Taylor expansion around the <em>interval</em> <code>x0</code> of order <code>_order</code>. The bound is computed by <code>bound_relrem</code>(@ref) exploiting monotonicity if possible, otherwise, it uses the Lagrange coefficient.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIntervals/TaylorModels.jl/blob/f844624021de8479f3327d8ba178c76425262f8f/src/rpa_functions.jl#L32-L42">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorModels.absorb_remainder-Union{Tuple{TaylorModelN{N,T,T}}, Tuple{T}, Tuple{N}} where T where N" href="#TaylorModels.absorb_remainder-Union{Tuple{TaylorModelN{N,T,T}}, Tuple{T}, Tuple{N}} where T where N"><code>TaylorModels.absorb_remainder</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">absorb_remainder(a::TaylorModelN)</code></pre><p>Returns a TaylorModelN, equivalent to <code>a</code>, such that the remainder is mostly absorbed in the constant and linear coefficients. The linear shift assumes that <code>a</code> is normalized to the <code>IntervalBox(-1..1, Val(N))</code>.</p><p>Ref: Xin Chen, Erika Abraham, and Sriram Sankaranarayanan, &quot;Taylor Model Flowpipe Construction for Non-linear Hybrid Systems&quot;, in Real Time Systems Symposium (RTSS), pp. 183-192 (2012), IEEE Press.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIntervals/TaylorModels.jl/blob/f844624021de8479f3327d8ba178c76425262f8f/src/validatedODEs.jl#L143-L154">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorModels.bound_integration-Union{Tuple{S}, Tuple{T}, Tuple{TaylorModel1{T,S},Any}} where S where T" href="#TaylorModels.bound_integration-Union{Tuple{S}, Tuple{T}, Tuple{TaylorModel1{T,S},Any}} where S where T"><code>TaylorModels.bound_integration</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">bound_integration(xTM1::TaylorModel1{Interval{S},S}, δt::Interval{S})
bound_integration(xTM1::Vector{TaylorModel1{Interval{S},S}}, δt::Interval{S})</code></pre><p>Remainder bound for the integration of a series, given by <span>$δ * remainder(a) +  a.pol[order] * δ^(order+1) / (order+1)$</span>. This is tighter that the one used by Berz+Makino, which corresponds to <span>$Δ = aux * remainder(a) +  a.pol[order] * aux^(order+1)$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIntervals/TaylorModels.jl/blob/f844624021de8479f3327d8ba178c76425262f8f/src/integration.jl#L35-L44">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorModels.bound_taylor1-Tuple{Taylor1,Interval}" href="#TaylorModels.bound_taylor1-Tuple{Taylor1,Interval}"><code>TaylorModels.bound_taylor1</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">bound_taylor1(fT::Taylor1, I::Interval)</code></pre><p>Compute a <em>tight</em> polynomial bound for the Taylor polynomial <code>fT</code> in the interval <code>I</code>.</p><p>Note: Algorithm 2.1.1 corresponds to <code>evaluate(fT, I)</code> or simply <code>fT(I). This function uses the roots of the derivative of</code>ft` to obtain a tighter bound.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIntervals/TaylorModels.jl/blob/f844624021de8479f3327d8ba178c76425262f8f/src/bounds.jl#L78-L88">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorModels.bound_taylor1-Union{Tuple{T}, Tuple{Taylor1{T},Taylor1{T},Interval{T}}} where T" href="#TaylorModels.bound_taylor1-Union{Tuple{T}, Tuple{Taylor1{T},Taylor1{T},Interval{T}}} where T"><code>TaylorModels.bound_taylor1</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">bound_taylor1(fT::Taylor1, fTd::Taylor1, I::Interval)</code></pre><p>Compute a <em>tight</em> polynomial bound for the Taylor polynomial <code>fT</code> in the interval <code>I</code>, considering whether its derivative <code>ftd</code> has a definite sign.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIntervals/TaylorModels.jl/blob/f844624021de8479f3327d8ba178c76425262f8f/src/bounds.jl#L113-L120">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorModels.check_existence-Union{Tuple{T}, Tuple{Any,T,T,Interval,Interval}, Tuple{Any,T,T,Interval,Interval,Integer}} where T&lt;:Union{RTaylorModel1, TaylorModel1}" href="#TaylorModels.check_existence-Union{Tuple{T}, Tuple{Any,T,T,Interval,Interval}, Tuple{Any,T,T,Interval,Interval,Integer}} where T&lt;:Union{RTaylorModel1, TaylorModel1}"><code>TaylorModels.check_existence</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">check_existence(f, tm::T, xm::T, x0::Interval, x_test::Interval)</code></pre><p>Checks that the range of one iterate of the Picard-Lindelöf operator is contained in the a-priori interval <code>x_test</code> (of the dependent variable) that bounds the solution of the ODE defined by <code>f</code>. This function returns an interval of the independent variable where the a-priori solution is warranted to exist; see <a href="#TaylorModels.shrink_for_existance-Union{Tuple{T}, Tuple{T,Any,Any}, Tuple{T,Any,Any,Integer}} where T&lt;:Union{RTaylorModel1, TaylorModel1}"><code>shrink_for_existance</code></a>. Here, <code>tm</code> and <code>xm</code> are Taylor Models (<code>TaylorModel1</code> or <code>RTaylorModel1</code>) defined for the independent and dependent variables, and <code>x0</code> is the initial condition.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIntervals/TaylorModels.jl/blob/f844624021de8479f3327d8ba178c76425262f8f/src/integration.jl#L77-L89">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorModels.iscontractive-Union{Tuple{T}, Tuple{N}, Tuple{IntervalBox{N,T},IntervalBox{N,T}}} where T where N" href="#TaylorModels.iscontractive-Union{Tuple{T}, Tuple{N}, Tuple{IntervalBox{N,T},IntervalBox{N,T}}} where T where N"><code>TaylorModels.iscontractive</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">iscontractive(Δ, Δx)</code></pre><p>Checks if <code>Δ .⊂ Δx</code> is satisfied. If `<code>Δ ⊆ Δx</code> is satisfied, it returns <code>true</code> if all cases where <code>==</code> holds corresponds to the zero <code>Interval</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIntervals/TaylorModels.jl/blob/f844624021de8479f3327d8ba178c76425262f8f/src/validatedODEs.jl#L68-L73">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorModels.picard_lindelöf-Union{Tuple{T}, Tuple{Any,T,T,Interval}} where T&lt;:Union{RTaylorModel1, TaylorModel1}" href="#TaylorModels.picard_lindelöf-Union{Tuple{T}, Tuple{Any,T,T,Interval}} where T&lt;:Union{RTaylorModel1, TaylorModel1}"><code>TaylorModels.picard_lindelöf</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">picard_lindelöf(f, tm::T, xm::T, x0::Interval)
𝒫(f, tm::T, xm::T, x0::Interval)</code></pre><p>Returns the application of the Picard-Lindelöf operator associated to the ODE <span>$\dot{x} = f(t,x)$</span>, with initial condition <code>x0</code>. Here, <code>tm</code> and <code>xm</code> are (one-variable) Taylor Models (<code>TaylorModel1</code> or <code>RTaylorModel1</code>).</p><p>𝒫 is an abbreviation of this operator, which is obtained as <code>\mscrP&lt;TAB&gt;</code>.)</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIntervals/TaylorModels.jl/blob/f844624021de8479f3327d8ba178c76425262f8f/src/integration.jl#L60-L71">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorModels.picard_remainder!-Union{Tuple{T}, Tuple{N}, Tuple{Function,Taylor1{T},Array{Taylor1{TaylorN{T}},1},Array{Taylor1{TaylorN{T}},1},Array{Taylor1{TaylorN{Interval{T}}},1},Array{Taylor1{TaylorN{Interval{T}}},1},IntervalBox{N,T},Interval{T},IntervalBox{N,T},IntervalBox{N,T},Any}} where T where N" href="#TaylorModels.picard_remainder!-Union{Tuple{T}, Tuple{N}, Tuple{Function,Taylor1{T},Array{Taylor1{TaylorN{T}},1},Array{Taylor1{TaylorN{T}},1},Array{Taylor1{TaylorN{Interval{T}}},1},Array{Taylor1{TaylorN{Interval{T}}},1},IntervalBox{N,T},Interval{T},IntervalBox{N,T},IntervalBox{N,T},Any}} where T where N"><code>TaylorModels.picard_remainder!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">picard_remainder!(f!, t, x, dx, xxI, dxxI, δI, δt, Δx, Δ0, params)</code></pre><p>Return the remainder of Picard operator</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIntervals/TaylorModels.jl/blob/f844624021de8479f3327d8ba178c76425262f8f/src/validatedODEs.jl#L85-L89">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorModels.reducetoorder-Tuple{RTaylorModel1,Integer}" href="#TaylorModels.reducetoorder-Tuple{RTaylorModel1,Integer}"><code>TaylorModels.reducetoorder</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">reducetoorder(a::RTaylorModel1, m::Integer)</code></pre><p>From <code>a::RTaylorModel1</code>, it returns a RTaylorModel1 of order <code>m</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIntervals/TaylorModels.jl/blob/f844624021de8479f3327d8ba178c76425262f8f/src/arithmetic.jl#L155-L160">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorModels.remainder_taylorstep!-Union{Tuple{T}, Tuple{N}, Tuple{Function,Taylor1{T},Array{Taylor1{TaylorN{T}},1},Array{Taylor1{TaylorN{T}},1},Array{Taylor1{Interval{T}},1},Array{Taylor1{Interval{T}},1},IntervalBox{N,T},Interval{T},Any}} where T where N" href="#TaylorModels.remainder_taylorstep!-Union{Tuple{T}, Tuple{N}, Tuple{Function,Taylor1{T},Array{Taylor1{TaylorN{T}},1},Array{Taylor1{TaylorN{T}},1},Array{Taylor1{Interval{T}},1},Array{Taylor1{Interval{T}},1},IntervalBox{N,T},Interval{T},Any}} where T where N"><code>TaylorModels.remainder_taylorstep!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">remainder_taylorstep!(f!, t, x, dx, xI, dxI, δI, δt, params)</code></pre><p>Returns a remainder for the integration step for the dependent variables (<code>x</code>) checking that the solution satisfies the criteria for existence and uniqueness.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIntervals/TaylorModels.jl/blob/f844624021de8479f3327d8ba178c76425262f8f/src/validatedODEs.jl#L3-L8">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorModels.shrink_for_existance-Union{Tuple{T}, Tuple{T,Any,Any}, Tuple{T,Any,Any,Integer}} where T&lt;:Union{RTaylorModel1, TaylorModel1}" href="#TaylorModels.shrink_for_existance-Union{Tuple{T}, Tuple{T,Any,Any}, Tuple{T,Any,Any,Integer}} where T&lt;:Union{RTaylorModel1, TaylorModel1}"><code>TaylorModels.shrink_for_existance</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">shrink_for_existance(xm::T, t_interval, x_test, max_steps::Integer=20)</code></pre><p>Shrinks the a-priori independent-variable interval <code>t_interval</code> so the range of <code>xm</code>, the Taylor Model (<code>TaylorModel1</code> or <code>RTaylorModel1</code>) associated with the dependent variable, is contained in the a-priori interval <code>x_test</code>. The method used is some sort of bisection. If no independent-variable interval is found within <code>max_steps</code>, an empty interval is returned.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIntervals/TaylorModels.jl/blob/f844624021de8479f3327d8ba178c76425262f8f/src/integration.jl#L102-L111">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorModels.shrink_wrapping!-Union{Tuple{Array{TaylorModelN{N,T,T},1}}, Tuple{T}, Tuple{N}} where T where N" href="#TaylorModels.shrink_wrapping!-Union{Tuple{Array{TaylorModelN{N,T,T},1}}, Tuple{T}, Tuple{N}} where T where N"><code>TaylorModels.shrink_wrapping!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">shrink_wrapping!(xTMN::TaylorModelN)</code></pre><p>Returns a modified inplace <code>xTMN</code>, which has absorbed the remainder by the modified shrink-wrapping method of Florian Bünger.</p><p>Ref: Florian B&quot;unger, Shrink wrapping for Taylor models revisited, Numer Algor 78:1001–1017 (2018), https://doi.org/10.1007/s11075-017-0410-1</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIntervals/TaylorModels.jl/blob/f844624021de8479f3327d8ba178c76425262f8f/src/validatedODEs.jl#L188-L196">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorModels.tight_remainder-Union{Tuple{T}, Tuple{Any,T,T,Interval}, Tuple{Any,T,T,Interval,Integer}} where T&lt;:Union{RTaylorModel1, TaylorModel1}" href="#TaylorModels.tight_remainder-Union{Tuple{T}, Tuple{Any,T,T,Interval}, Tuple{Any,T,T,Interval,Integer}} where T&lt;:Union{RTaylorModel1, TaylorModel1}"><code>TaylorModels.tight_remainder</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">tight_remainder(f, tm::T, xm::T, x0::Interval, max_steps::Integer=20)</code></pre><p>Returns a Taylor Model for the dependent variable, with a tighter remainder, which is obtained after successive iteration of the Picard-Lindelöf. If the remainder is not tighter (and identity with the former iterate is not obtained) a Taylor Model with an empty interval is returned.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIntervals/TaylorModels.jl/blob/f844624021de8479f3327d8ba178c76425262f8f/src/integration.jl#L147-L156">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorModels.validated_step!-Union{Tuple{T}, Tuple{N}, Tuple{Any,Taylor1{T},Array{Taylor1{TaylorN{T}},1},Array{Taylor1{TaylorN{T}},1},Array{Taylor1{TaylorN{T}},1},Taylor1{T},Array{Taylor1{Interval{T}},1},Array{Taylor1{Interval{T}},1},Array{Taylor1{Interval{T}},1},T,T,Array{TaylorModelN{N,T,T},1},Array{IntervalBox{N,T},1},Array{Interval{T},1},IntervalBox{N,T},IntervalBox{N,T},IntervalBox{N,T},Int64,Int64,T,Any,Bool}, Tuple{Any,Taylor1{T},Array{Taylor1{TaylorN{T}},1},Array{Taylor1{TaylorN{T}},1},Array{Taylor1{TaylorN{T}},1},Taylor1{T},Array{Taylor1{Interval{T}},1},Array{Taylor1{Interval{T}},1},Array{Taylor1{Interval{T}},1},T,T,Array{TaylorModelN{N,T,T},1},Array{IntervalBox{N,T},1},Array{Interval{T},1},IntervalBox{N,T},IntervalBox{N,T},IntervalBox{N,T},Int64,Int64,T,Any,Bool,Function}} where T where N" href="#TaylorModels.validated_step!-Union{Tuple{T}, Tuple{N}, Tuple{Any,Taylor1{T},Array{Taylor1{TaylorN{T}},1},Array{Taylor1{TaylorN{T}},1},Array{Taylor1{TaylorN{T}},1},Taylor1{T},Array{Taylor1{Interval{T}},1},Array{Taylor1{Interval{T}},1},Array{Taylor1{Interval{T}},1},T,T,Array{TaylorModelN{N,T,T},1},Array{IntervalBox{N,T},1},Array{Interval{T},1},IntervalBox{N,T},IntervalBox{N,T},IntervalBox{N,T},Int64,Int64,T,Any,Bool}, Tuple{Any,Taylor1{T},Array{Taylor1{TaylorN{T}},1},Array{Taylor1{TaylorN{T}},1},Array{Taylor1{TaylorN{T}},1},Taylor1{T},Array{Taylor1{Interval{T}},1},Array{Taylor1{Interval{T}},1},Array{Taylor1{Interval{T}},1},T,T,Array{TaylorModelN{N,T,T},1},Array{IntervalBox{N,T},1},Array{Interval{T},1},IntervalBox{N,T},IntervalBox{N,T},IntervalBox{N,T},Int64,Int64,T,Any,Bool,Function}} where T where N"><code>TaylorModels.validated_step!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">validated-step!</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIntervals/TaylorModels.jl/blob/f844624021de8479f3327d8ba178c76425262f8f/src/validatedODEs.jl#L294-L296">source</a></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a></footer></article></body></html>
